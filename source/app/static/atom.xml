<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>意外</title>
  <subtitle>俞坤的博客</subtitle>
  <link rel="alternate" type="text/html" href="http://www.yukunweb.com/"/>
  <link href="http://www.yukunweb.com/atom.xml" rel="self"/>
  <id>tag:www.yukunweb.com,2017-05-25://1</id>
  <updated>2018-12-09T00:00:00Z</updated>
  <generator uri="https://github.com/Blackyukun/YuBlog">YuBlog</generator>

  <entry>
    <title>asd</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/12/asd"/>
    <id>tag:www.yukunweb.com,2018://1.44</id>
    <published>2018-12-09T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>asd</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="sad" scheme="http://www.yukunweb.com/category/sad"/>
    <content type="html"><![CDATA[<p>adsad</p>]]></content>
  </entry>
  <entry>
    <title>读三体</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/8/read-three-body"/>
    <id>tag:www.yukunweb.com,2018://1.43</id>
    <published>2018-08-28T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>读三体</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="阅读" scheme="http://www.yukunweb.com/category/阅读"/>
    <content type="html"><![CDATA[<p>最近我用了两个星期读完了刘慈欣的三体三部曲，《地球往事》、《黑暗森林》、《死神永生》。因为是科幻小说，作者从上帝视角，以宏大的时间跨度，去叙述两个文明在宇宙中为了生存，付诸的努力。本文尽量不叙述小说的剧情。</p>
<p><img alt="post39_1" src="https://www.yukunweb.com/qiniu/post39_1.jpg" /></p>
<p><img alt="post39_2" src="https://www.yukunweb.com/qiniu/post39_2.jpg" /></p>
<p>故事开始于黑暗的文革时期。对现实世界心灰意冷的叶文洁，按下发射键。发出了地球文明向宇宙的第一声啼哭，内容是"Hello World!"。苦苦挣扎在毁灭与重生之间的三体文明在收到来自地球的信息后，开始了长达四百多年的侵略地球的旅途，为了抑制地球科学发展的突飞猛进，他们发出了能够锁死地球基础科学的智子，于此同时，智子也在无时无刻的监视着地球人类的一举一动。</p>
<p>《地球往事》以纳米材料科学家王淼的视角，将三体的故事线，逐渐展开。之前有朋友问我，你是降临派还是拯救派。虽然我的思想上倾向于拯救派，但是就地球三体组织的成员身份，我们大部分人，根本无法掌握地球的命运，只能做底层的幸存派。《地球往事》中影响深刻的是，在认识到地球不可能胜利的物理学家丁仪，消极度日。大史带他们去看闹蝗灾的麦田时，大史说，人类用尽各种手段，毒药，基因改造，但是蝗虫至今仍未灭绝，甚至数量也未减少。是的，虽然技术相差很大，但是虫子从未被战胜过。虽然这只是一个很天真的比喻，但是多少有点道理。</p>
<p>《黑暗森林》主要叙述人类面对未来三体文明的侵略，做出的抵抗计划。书中核心人物是罗辑。人类从地球三体组织的资料中得到，三体人的思维是透明的，他们难以理解地球人的谎言计谋。由于三体人通过智子一直在看着地球人的一举一动，地球人提出面壁计划，意在以面壁人一己的思考，带给人类生存的希望。</p>
<p>《黑暗森林》结尾部分，罗辑从冬眠中醒来已过去了一百八十多年，三体舰队距离地球二百多年。地球人在经历了大低谷时期，地球人类数量从80亿减少到30亿。大低谷时期的结束，人类的思想解放了，文化科技得到突飞猛进的发展。在罗辑冬眠前还是人类认为的未来救世主，醒来后，什么面壁计划就是笑话。而三体舰队被地球人认为是可怜的自寻死路，甚至他们已经想好了怎样人性化的安顿三体人。在地球太空舰队被三体探测器摧枯拉朽的摧毁后， 罗辑黑暗森林法则的证明，给了我很大的震撼。人类也以此躲过了被消灭的命运，罗辑再一次成了救世主。</p>
<p>《死神永生》从科幻小说的境界来说，是明显超过前两本的。威慑纪元，地球人以黑暗森林法则威胁三体舰队，得以继续生存下去。人们推选程心接任罗辑，成为执剑人。给三体人反攻的机会，地球文明终于被三体文明控制。在宇宙中漂流的幸存地球舰"蓝色空间"号打破了黑暗森林法则。三体文明为了生存，抛弃地球，自己的母星被其他文明摧毁。歌者文明的清扫者，像太阳系打出二向箔。太阳系从三维跌入二维，地球文明毁灭。犯了很多次错误的程心，乘坐唯一拥有曲率驱动引擎的飞船光速逃离太阳系，给地球文明留下一丝在宇宙中存在过的记号。</p>
<p>三部读完的时候，已是深夜，我望向窗外，看着远处最后一班地铁飞驰而过，南京的夜空竟然可以看到几颗暗淡的星星。黑夜中，听着林俊杰唱到：“阳光放弃这最后一秒，让世界被黑暗笼罩，惩罚着人们的骄傲，我忍受寒冷的煎熬，和北风狂妄的咆哮，对命运做抵抗”。只觉得自己像是被丢在无边沙漠中的孩子。叶文洁说：“有时觉得生命真珍贵，一切都重如泰山；有时有觉得人是那么渺小，什么都不值一提。”</p>
<p>书中，作者以平淡到有些麻木的文字描述着人性的恶。危机开始时，国际准备实行逃亡策略。既然明知道无法胜利，不如让更多的人乘坐飞船逃离地球。可是在生存面前出现不平等，意味着人类价值观和道德底线的崩塌。坐不起逃亡飞船的人或者国家，是不可能眼睁睁的看着别人走而自己等死的，这必然会出现世界打乱。其实这是很平常的现象，人类历史朝代的更迭都是社会分配不平等造成的。不患贫而患不均，是深植于人类灵魂的思想。</p>
<p>威慑纪元，人类假意骗回了消灭友舰的"青铜时代"号。在宇宙中漂流很久的"青铜时代"号成员，以为回家了，可面对他们的却是道德的审判。他们为了生存，消灭了同样幸存下来的地球太空舰，甚至保留友舰成员的尸体作为。。。这在重获自由的地球人看来是不可容忍的。但是他们也是为了生存，生存是文明的第一需要，生存面前，一切都不值一提。最后"青铜时代"号，像同在宇宙漂流的"蓝色空间"号，发出讯息“不要回来，这里不是家”。</p>
<p>大部分读者肯定很讨厌程心，她是一个圣母心泛滥的人。为了大部分人的安全，她犯了很多错误。但是我觉得这不能责怪她。她被选为执剑人做救世主，和被推上断头台是一个性质的，都别无选择。她没有给三体人以威慑，导致地球沦陷。地球人开始责怪与她，而如果她发出了宇宙广播，地球人一样会责怪于她。她也只是一个普通人，被推选为救世主，就必定要为婴儿般的地球人负责吗？掩体纪元，她终止了维德的曲率驱动引擎飞船的计划，是圣母心泛滥的标志，也彻底终结了人类存活的希望。当然大刘在最后替她的决定找了合理的理由。维德说：“失去人性，失去很多；失去兽性，失去一切”。程心选择了人性，这是错误的吗？</p>
<p>《三体》是一部很伟大的科幻小说，作者向我们展现了宇宙中残酷的生存法则，以及文明面对生存威胁时，做出的努力。最后记录书中最好的句子共勉：</p>
<blockquote>
<p>弱小与无知不是生存的障碍，傲慢才是。</p>
</blockquote>
<p>敬畏技术，谦卑前行。</p>]]></content>
  </entry>
  <entry>
    <title>从contextlib源码谈with语句</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/8/Talking-with-from-the-ontextlib-source"/>
    <id>tag:www.yukunweb.com,2018://1.42</id>
    <published>2018-08-13T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>从contextlib源码谈with语句</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="技术" scheme="http://www.yukunweb.com/category/技术"/>
    <content type="html"><![CDATA[<p>上一篇文章中，解决<em>RuntimeError: Working outside of application context.</em>错误，使用手动将应用上下文推入栈中：</p>
<div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>


<p>而 flask 文档中给我们的解决代码是：</p>
<div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p>它使用了<code>python</code>的<code>with</code>语句，使得代码更加简洁。</p>
<h2>AppContext 类</h2>
<p>with语句的关键是需要实现<code>__enter__</code>和<code>__exit__</code>类方法，来看一下 flask 的<code>AppContext</code>类的实现：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">AppContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Binds the app context to the current context.&quot;&quot;&quot;</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">_sentinel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pops the app context.&quot;&quot;&quot;</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">exc_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">BROKEN_PYPY_CTXMGR_EXIT</span> <span class="ow">and</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">reraise</span><span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span>
</pre></div>


<p><code>AppContext</code>类的<code>__enter__</code>方法实现了<code>push()</code>入栈，<code>__exit__</code>方法实现了<code>pop()</code>出栈。可以让我们不需要啰嗦的再去写入栈出栈语句。</p>
<h2>with语句</h2>
<p>怎样自己实现with语句呢？首先需要知道<a href="https://www.python.org/dev/peps/pep-0343/" target="_blank">pep0343</a>。</p>
<p>该PEP建议实现了<code>__enter__()</code> 和<code>__exit__()</code>方法的协议称为<strong>上下文管理协议</strong>，实现该协议的对象称为<strong>上下文管理器</strong>。紧跟<code>with</code>关键字之后的表达式是<strong>上下文表达式</strong>，上下文表达式必须要返回一个上下文管理器。</p>
<h2>contextlib</h2>
<p>python的标准库提供了<code>contextlib</code>模块来帮助编写<code>__enter__</code>和<code>__exit__</code>方法。<code>contextlib</code>模块提供了<code>contextmanager</code>装饰器，它接受一个生成器(generator)，用<code>yield</code>语句把<code>with ... as var</code>的结果输出出去。这样就可以使用<code>with</code>语句了。看下面例子：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">opened</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;r&quot;</span><span class="p">):</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">file</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;end&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">opened</span><span class="p">(</span><span class="s">&quot;/etc/passwd&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</pre></div>


<p>程序在<code>with</code>语句块的执行前后分别打印了<em>start</em>和<em>end</em>。跟踪这个装饰器，看看他的实现源码：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">contextmanager</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_GeneratorContextManager</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">helper</span>
</pre></div>


<p>他的内部返回一个类的实例<code>_GeneratorContextManager(func, args, kwds)</code>，继续跟踪他：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">_GeneratorContextManager</span><span class="p">(</span><span class="n">ContextDecorator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for @contextmanager decorator.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">):</span>
        <span class="c"># 初始化实例，将传入的函数赋值给gen属性，此时函数未执行</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c"># 依然是赋值</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span>

    <span class="k">def</span> <span class="nf">_recreate_cm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 调用装饰器时都必须重新创建实例</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># __enter__()方法</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># next()函数是返回一次生成器的值，</span>
            <span class="c"># self.gen是传给contextmanager装饰器传给该类的生成器函数哦，</span>
            <span class="c"># 看上面的__init__()初始化实例方法</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c"># 如果生成器没有更多的元素返回时，会抛出StopIteration的错误。</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;generator didn&#39;t yield&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="c"># __exit__()方法，这几个参数是什么，看下面</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;generator didn&#39;t stop&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;generator didn&#39;t stop after throw()&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">__cause__</span> <span class="ow">is</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">raise</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">raise</span>

<span class="k">class</span> <span class="nc">ContextDecorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">&quot;A base class or mixin that enables context managers to work as decorators.&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recreate_cm</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inner</span>
</pre></div>


<p><code>_GeneratorContextManager(func, args, kwds)</code>的源码很简单明了，看上面的注释基本上可以理解。该类实现了<code>__enter__()</code> 和<code>__exit__()</code>方法，也就是个<strong>上下文管理器</strong>。</p>
<p><code>__enter__()</code> 和<code>__exit__()</code>这两个方法其实很好理解，前者还是在<code>with</code>语句块执行前调用，后者实在语句块执行后调用。</p>
<h2>__enter__()</h2>
<p>上面的例子中，<code>with</code>语句<code>as</code>关键词后面的<code>f</code>，是什么。如果在<code>with</code>语句块中使用<code>next(f)</code>调用他，他仍然可以正确的输出一行内容。这说明<code>f</code>其实就是<code>file = open()</code>的生成器。他是如何被赋值的。似乎只有在<code>_GeneratorContextManager()</code>类的<code>__enter__()</code>方法中，可以看到他返回了一个<code>next(self.gen)</code>，注意这里他并没有被执行。他返回的结果会被赋值给<code>as</code>关键词后面的变量。以一个例子来演示：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Demo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;hello, &#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;end&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Demo</span><span class="p">()</span> <span class="k">as</span> <span class="n">h</span><span class="p">:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&#39;world&#39;</span><span class="p">)</span>
</pre></div>


<p>执行结果：</p>
<div class="highlight"><pre>start
hello,  world
end
</pre></div>


<h2>__exit__()</h2>
<p>从上文的几个例子中可以看到，<code>__exit__()</code>方法接收除<code>self</code>外三个参数。从<code>_GeneratorContextManager()</code>类的源码，可以看出他似乎是做的一些上下文管理器的错误处理。仍然以上面的例子，分别打印三个参数来演示：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Demo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;hello, &#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;end&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;type: &#39;</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;val: &#39;</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;tb: &#39;</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Demo</span><span class="p">()</span> <span class="k">as</span> <span class="n">h</span><span class="p">:</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="n">h</span><span class="o">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&#39;world&#39;</span><span class="p">)</span>
</pre></div>


<p>执行结果：</p>
<div class="highlight"><pre>Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">&quot;C:/Users/Administrator/Desktop/Eager/spider.py&quot;</span>, line 71, in &lt;module&gt;
    1/0
ZeroDivisionError: division by zero
start
end
<span class="nb">type</span>:  &lt;class <span class="s1">&#39;ZeroDivisionError&#39;</span>&gt;
val:  division by zero
tb:  &lt;traceback object at 0x0000000000E34C88&gt;
</pre></div>


<p>可以看到，程序报了<code>ZeroDivisionError</code>的错误，再看各个参数的返回的值。他们对比一下不难发现：</p>
<ul>
<li>exc_type: 异常类型</li>
<li>exc_val: 异常信息</li>
<li>exc_tb: 异常追踪信息</li>
</ul>
<p><code>_GeneratorContextManager()</code>类中的<code>__exit__()</code>方法的一些判断语句是不是很容易理解了。</p>
<p>其实<code>__exit__()</code>方法还可以使用<code>return</code>语句，返回<code>False</code>或者<code>True</code>可以对<code>with</code>语句块的错误进行抛出或者隐藏。</p>
<p>参考文章：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001478651770626de401ff1c0d94f379774cabd842222ff000" target="_blank">廖雪峰的python教程</a></p>
<p><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank">PEP343</a></p>]]></content>
  </entry>
  <entry>
    <title>Flask的经典错误</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/7/Flask-classic-error"/>
    <id>tag:www.yukunweb.com,2018://1.41</id>
    <published>2018-07-29T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>Flask的经典错误</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="技术" scheme="http://www.yukunweb.com/category/技术"/>
    <content type="html"><![CDATA[<p>在编写 Flask 应用的单元测试，离线应用时候经常会遇到，<em>RuntimeError: Working outside of application context.</em>的报错。这个报错是在没有激活程序上下文情况下，进行了一些程序上下文或请求上下文的操作。先看下面的两段代码：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">current_app</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">current_app</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">&#39;hello, world&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>


<p>如果运行第一段代码，他就会报错：RuntimeError: Working outside of application context. 而第二段代码却不会。为什么会这样呢，使用搜索引擎或者直接在flask文档中，可以找到他的完美解决方案。但是可能知道怎么处理这个错误，却不知道他为何会这样，所以如果有时间，我建议去看相关源码。如果使用pycharm做IDE，只需要按住<code>ctrl</code>然后左键点击<code>current_app</code>就可以跳到flask该部分的源码。</p>
<h2>源码分析</h2>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_find_app</span><span class="p">():</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">_app_ctx_stack</span><span class="o">.</span><span class="n">top</span>
    <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">_app_ctx_err_msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">top</span><span class="o">.</span><span class="n">app</span>

<span class="c"># context locals</span>
<span class="n">_app_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">current_app</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_find_app</span><span class="p">)</span>
</pre></div>


<p>可以看到，<code>current_app</code>是一个<code>LocalProxy</code>的实例，不去管<code>werkzeug</code>的部分，直接看这个初始化实例时接受的参数<code>_find_app</code>。可以看到<code>_find_app</code>是一个函数，他的代码也很简单，第一句<code>top = _app_ctx_stack.top</code>。<code>_app_ctx_stack</code>是flask的应用上下文栈(栈，是一种后进先出的数据结构)，当然从命名中就可以看出来，而它又是<code>LocalStack()</code>类的实例。接着往下看<code>LocalStack()</code>的部分：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">LocalStack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c"># ...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The topmost item on the stack.  If the stack is empty,</span>
<span class="sd">        `None` is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p><code>LocalStack()</code>类实现了入栈<code>push()</code>，出栈<code>pop()</code>。而<code>top</code>是一个属性，他不是出栈，是拿到栈顶的元素。那可以知道<code>_find_app()</code>函数是要拿到当前应用上下文。如果拿到他就返回<code>top.app</code>，那么<code>current_app</code>其实是当前应用上下文的<code>app</code>实例(先不管他怎么实现的)。而如果拿不到这个top，栈顶没有元素，他就会抛出这个经典错误<code>raise RuntimeError(_app_ctx_err_msg)</code>。</p>
<p>解决这个错误，最简单的办法就是在调用<code>current_app</code>实例前，将当前应用上下文推入栈中。首先要得到应用上下文对象，幸运的是flask应用对象提供了<code>app_context()</code>方法，直接调用他，将得到一个上下文对象。</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">current_app</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p><code>ctx</code>并其实调用的是<code>_app_ctx_stack</code>的<code>push()</code>入栈哦。跳到<code>app_context()</code>的源码，可以看到他其实是返回了应用上下文<code>AppContext()</code>类的实例，并且传给了他<code>self</code>。<code>python</code>中默认<code>selef</code>代表的是类的实例，这里就是<code>app</code>应用实例。下面接着看<code>AppContext()</code>代码。</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">AppContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refcnt</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Binds the app context to the current context.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refcnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s">&#39;exc_clear&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exc_clear</span><span class="p">()</span>
        <span class="n">_app_ctx_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">appcontext_pushed</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">_sentinel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pops the app context.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refcnt</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refcnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
                    <span class="n">exc</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">do_teardown_appcontext</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">_app_ctx_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">rv</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&#39;Popped wrong app context.  (</span><span class="si">%r</span><span class="s"> instead of </span><span class="si">%r</span><span class="s">)&#39;</span> \
            <span class="o">%</span> <span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">appcontext_popped</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">)</span>
</pre></div>


<p>很明显，<code>AppContext()</code>类实现了入栈和出栈，其实就是调用了应用上下文<code>_app_ctx_stack</code>的方法。而他<code>push()</code>的是<code>self</code>，就是该类的实例。所以上面<code>_find_app()</code>函数返回<code>top.app</code>，就是<code>app</code>实例（这里有点绕QAQ~）。大致如下：</p>
<ol>
<li><code>app=Flask(__name__)</code>，app 是<code>Flask</code>的实例，</li>
<li><code>app.app_context()</code>，调用 <code>Flask</code> 类里的<code>app_context(self)</code>方法，</li>
<li><code>app_context(self)</code>返回<code>AppContext()</code>类实例，传给他 self，</li>
<li><code>self</code> 是 <code>Flask</code> 类的实例，即 app，</li>
<li><code>AppContext()</code>类初始化实例，需要传入 app 属性，<code>self.app = app</code>，</li>
<li><code>AppContext()</code>类的push方法，调用<code>_app_ctx_stack.push(self)</code>，</li>
<li><code>_app_ctx_stack.push(self)</code>中传入的<code>self</code>是<code>AppContext()</code>类的实例(他有app属性，见第5行)，</li>
<li><code>_app_ctx_stack.push(self)</code>就是将应用上下文实例推入应用上下文栈，</li>
<li><code>_find_app()</code>返回<code>_app_ctx_stack.app</code>，即是返回栈中上下文的<code>app</code>实例，</li>
<li><code>current_app = LocalProxy(_find_app)</code>拿到这个 app 实例。</li>
</ol>
<p><img alt="post37_1" src="https://www.yukunweb.com/qiniu/post37_0.png" /></p>
<h2>疑问</h2>
<p>上面的代码，把应用上下文推入栈中，运行的时候仍然会报错<code>AssertionError: Popped wrong app context.</code>。这是因为在请求结束，需要调用<code>ctx.pop()</code>将应用上下文弹出栈。</p>
<p>那么为什么在正常的路由中，调用<code>current_app</code>请求却不会抛出<code>Working outside of application</code>的错误呢？</p>
<p>Flask其实不仅仅有应用上下文，还有请求上下文：</p>
<div class="highlight"><pre><span class="n">_request_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">_app_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">current_app</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_find_app</span><span class="p">)</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_req_object</span><span class="p">,</span> <span class="s">&#39;request&#39;</span><span class="p">))</span>
</pre></div>


<p>请求上下文同样使用栈保存。在正常的flask路由请求中，flask会在将请求上下文入栈前，判断<code>_app_ctx_stack</code>栈顶是否存在应用上下文，如果不存在，flask会自己先将它入栈。下面来看一下flask是如何处理的，首先在flask代码里找到哪里有将请求上下文入栈的代码：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_ignore_error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">auto_pop</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The WSGI server calls the Flask application object as the</span>
<span class="sd">    WSGI application. This calls :meth:`wsgi_app` which can be</span>
<span class="sd">    wrapped to applying middleware.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>


<p>看这个方法名，应该是个符合WSGI标准的一个HTTP处理函数。关于WSGI是什么以及他的参数<code>environ, start_response</code>是什么，可以参考这篇文章 <a href="https://www.yukunweb.com/2018/2/understand-python-web/#WSGI" target="_blank">理解Python的Web开发</a>。</p>
<div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
</pre></div>


<p>跟踪<code>self.request_context(environ)</code>方法，他返回<code>RequestContext()</code>类实例。看该类的<code>push()</code>方法：</p>
<div class="highlight"><pre>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">top</span><span class="o">.</span><span class="n">preserved</span><span class="p">:</span>
            <span class="n">top</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">_preserved_exc</span><span class="p">)</span>
        <span class="c"># Before we push the request context we have to ensure that there</span>
        <span class="c"># is an application context.</span>
        <span class="n">app_ctx</span> <span class="o">=</span> <span class="n">_app_ctx_stack</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="n">app_ctx</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">app_ctx</span><span class="o">.</span><span class="n">app</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">:</span>
            <span class="n">app_ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
            <span class="n">app_ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_app_ctx_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">app_ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_app_ctx_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s">&#39;exc_clear&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exc_clear</span><span class="p">()</span>

        <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>


<p>可以看到在请求上下文入栈前，会先将请求上下文入栈<code>app_ctx.push()</code>。</p>
<p>那这个<code>wsgi_app</code>方法是在哪里调用的，截取<code>wsgi_app</code>方法的代码时，我也截取了下面的<code>__call__</code>定制类方法，不理解改个方法的参考这篇文章<a href="https://www.yukunweb.com/2018/1/Python-custom-class-notes/#__call__" target="_blank">Python的定制类笔记</a>。它让我们能像调用函数那样调用实例方法，而它返回的正是<code>self.wsgi_app(environ, start_response)</code>。那要调用<code>wsgi_app</code>方法只需要：</p>
<div class="highlight"><pre><span class="c"># 实例Flask类</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="c"># 函数一样调用他</span>
<span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>


<p><code>wsgi_app</code>方法是一个HTTP处理函数，拿他肯定会在flask应用启动的时候被调用，我们看<code>run()</code>方法：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">load_dotenv</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">run_simple</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_got_first_request</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>


<p>可以看到<code>app.run()</code>其实是调用了<code>werkzeug</code>库的<code>run_simple</code>方法，该方法接收的第三个参数就是应用程序实例了，他会在<code>werkzeug</code>库的<code>wsgi.py</code>中像函数一样被调用: <code>self.app(environ, start_response)</code>，启动flask的<code>wsgi_app</code>方法。</p>
<h2>最后</h2>
<p>flask代码的注释写的很详细，他的文档大部分就是他的注释。所以，看flask源码的难度其实是很低的。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/u013210620/article/details/80071855" target="_blank">Flask---上下文源码分析</a></p>]]></content>
  </entry>
  <entry>
    <title>Nginx场景实践</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/6/Nginx-scene-practice"/>
    <id>tag:www.yukunweb.com,2018://1.39</id>
    <published>2018-06-30T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>Nginx场景实践</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="技术" scheme="http://www.yukunweb.com/category/技术"/>
    <content type="html"><![CDATA[<p><code>Nginx</code>(读作：恩静 X)是一个高性能的<code>HTTP</code>和反向代理服务器，一个邮件代理以及通用的<code>TCP/ UDP</code>代理服务器。本篇文章是我最近使用<code>Nginx</code>的记录。你发现本站已经是全站<code>https</code>了，而本站的图片是放在七牛云的。之所以可以使用<code>https://www.yukun.com/qiniu/xxx</code>访问到存放在七牛的图片，是因为使用了<code>nginx</code>的反向代理。</p>
<h2>安装</h2>
<p>我们使用<code>Docker</code>启动一个<code>ubuntu</code>容器来演示安装过程：</p>
<div class="highlight"><pre><span class="nv">$ </span>sudo docker run -t -i -p 80：80 ubuntu:16.04 /bin/bash
root@bbf4a330635d:/# <span class="nb">cd </span>root
root@bbf4a330635d:~#
</pre></div>


<p>进入容器后，开始安装nginx：</p>
<h3>apt-get安装</h3>
<div class="highlight"><pre><span class="nv">$ </span>apt-get update  // 更新软件源
<span class="nv">$ </span>apt-get install nginx  // 更新软件源
<span class="nv">$ </span>nginx   // 启动
<span class="nv">$ </span>ps -ef   // 显示所有进程信息
UID        PID  PPID  C STIME TTY          TIME CMD
root         <span class="m">1</span>     <span class="m">0</span>  <span class="m">0</span> 08:26 pts/0    00:00:00 /bin/bash
root      <span class="m">3757</span>     <span class="m">1</span>  <span class="m">0</span> 08:58 ?        00:00:00 nginx: master process nginx
www-data  <span class="m">3758</span>  <span class="m">3757</span>  <span class="m">0</span> 08:58 ?        00:00:00 nginx: worker process
root      <span class="m">3759</span>     <span class="m">1</span>  <span class="m">0</span> 08:58 pts/0    00:00:00 ps -ef
</pre></div>


<h3>源码编译安装</h3>
<p>上一种的安装方式，在生产环境下可能会显得自定义性不强，或者安装包比较老。更多的时候我们需要下载源码编译安装。</p>
<div class="highlight"><pre><span class="nv">$ </span>wget http://nginx.org/download/nginx-1.14.0.tar.gz  // 目前最新稳定版
<span class="nv">$ </span>tar -zxvf nginx-1.14.0.tar.gz //解压
<span class="nv">$ </span><span class="nb">cd </span>nginx-1.14.0.tar.gz  
<span class="nv">$ </span>apt-get install libpcre3 libpcre3-dev zlib1g-dev build-essential libtool  // 编译前安装依赖包
<span class="nv">$ </span>./configure  // 可以在后面定制安装
<span class="nv">$ </span>make
<span class="nv">$ </span>sudo make install
</pre></div>


<p>这样我们就安装成功了，默认情况<code>nginx</code>会安装在<code>/usr/local/nginx</code>目录中启动：</p>
<div class="highlight"><pre><span class="nv">$ </span>/usr/local/nginx/sbin/nginx   // 启动
<span class="nv">$ </span>/usr/local/nginx/sbin/nginx -s reload  // 重启
<span class="nv">$ </span>/usr/local/nginx/sbin/nginx -s stop   // 关闭进程
<span class="nv">$ </span>/usr/local/nginx/sbin/nginx -s quit  // 平滑关闭nginx
</pre></div>


<h2>反向代理</h2>
<p>假如用户 A 要得到网站 C 的内容，而用户 A 因为网络原因又不能直接访问到，而服务器 B 可以访问到网站 C，那服务器可以得到网站 C 的内容再存起来发给用户 A，这整个过程用户 A 是直接和服务器 B 交互的，用户 A 不知道网站 C 的存在。那web服务器 B 就是一台反向代理服务器，C 是上游服务器。</p>
<p><code>nginx</code>的反向代理是依赖于<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>这个自带<code>module</code>来实现的。我们以本站图片请求反向代理为例：</p>
<p>由于本站用的是<code>https</code>协议，在浏览器的地址栏可以看到绿色的锁。而如果图片不是存储在本地服务器，而是放在七牛，又拍云这样的地方，图片的外链是<code>http</code>协议的(当然七牛本身是可以开启<code>https</code>协议的，只是并非免费)。那么在浏览器的地址栏，虽然显示的是<code>https</code>协议，却没有绿色安全锁。</p>
<p>所以我们要把<code>https</code>协议请求的图片地址反向代理到<code>http</code>协议的真实图片上。事实上<code>https</code>协议请求的图片是不存在，而如果使用反向代理，它就有一个指向http协议图片的实际地址。</p>
<div class="highlight"><pre><span class="k">server</span> <span class="p">{</span>
  <span class="kn">server_name</span>    <span class="s">www.yukunweb.com</span><span class="p">;</span>
  <span class="kn">listen</span>         <span class="mi">443</span><span class="p">;</span>  <span class="c1"># 443端口用于HTTPS服务</span>
  <span class="kn">location</span> <span class="s">/qiniu/post36_0.jpg</span> <span class="p">{</span>
    <span class="kn">proxy_pass</span> <span class="s">http://opxib6gmc.bkt.clouddn.com/post36_0.jpg</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">opxib6gmc.bkt.clouddn.com</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kn">location</span> <span class="s">/example.jpg</span> <span class="p">{</span>
    <span class="kn">proxy_pass</span> <span class="s">http://example.com/example.jpg</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这样我们就可以通过访问<code>https://www.yukunweb.com/qiniu/post36_0.jpg</code>来请求到<code>http://opxib6gmc.bkt.clouddn.com/post36_0.jpg</code>的图片。</p>
<p><code>Nginx</code>的<code>sever</code>块主要是服务器的配置(域名，IP，端口等)，在一个<code>Nginx</code>的配置文件里面，我们可以有多个<code>sever</code>块配置。而<code>location</code>块则是在<code>sever</code>块里面，对不同请求路径进行的配置。因为一个站点中的<code>URI</code>通常会非常多，所以在<code>location</code>块设置这部分，同样可以写多个<code>location</code>的配置。当然我们不能为每一个<code>URI</code>都进行配置，我们来看一些动态匹配语法：</p>
<h3>location语法说明</h3>
<div class="highlight"><pre><span class="n">syntax</span><span class="o">:</span> <span class="n">location</span> <span class="o">[=|~|~*|^~|</span><span class="err">@</span><span class="o">]</span> <span class="sr">/uri/</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">default</span><span class="o">:</span> <span class="n">no</span>
<span class="n">context</span><span class="o">:</span> <span class="n">server</span>
</pre></div>


<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>表示精确匹配，不支持正则</td>
</tr>
<tr>
<td>^~</td>
<td>表示uri以某个常规字符串开头，不支持正则，理解为匹配uri路径即可</td>
</tr>
<tr>
<td>~和~*</td>
<td>表示区分大小写的和不区分大小写的正则匹配</td>
</tr>
<tr>
<td>!~和!~*</td>
<td>表示区分大小写不匹配和不区分大小写不匹配的正则匹配</td>
</tr>
<tr>
<td>/</td>
<td>通用匹配，任何请求都会匹配</td>
</tr>
</tbody>
</table>
<p>匹配优先级 ：<code>=</code> &gt; <code>^~</code> &gt; <code>~/~*/!~/!~*</code> &gt; <code>/</code>。优先级的意思是当以<code>~/~*/!~/!~*</code>和<code>/</code>匹配到符合结果路径后，会继续往下判断其他配置项的匹配，如果<code>^~</code>语法也匹配到符合的则使用<code>^~</code>匹配到的结果，而<code>^~</code>匹配到结果后就不会再往下判断其他配置项是否满足。</p>
<p><code>proxy_set_header</code>配置重写请求上游服务器头的内容，我们这里设置了请求头<code>Host</code>参数。</p>
<p>现在我们重新写上面的配置：</p>
<div class="highlight"><pre><span class="k">server</span> <span class="p">{</span>
  <span class="kn">server_name</span>    <span class="s">www.yukunweb.com</span><span class="p">;</span>
  <span class="kn">listen</span>         <span class="mi">443</span><span class="p">;</span>  <span class="c1"># 443端口用于HTTPS服务</span>
  <span class="kn">location</span> <span class="s">^~</span> <span class="s">/qiniu/</span> <span class="p">{</span>
    <span class="kn">proxy_pass</span> <span class="s">http://opxib6gmc.bkt.clouddn.com/</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">opxib6gmc.bkt.clouddn.com</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1"># 反向代理avatar.com的头像</span>
  <span class="kn">location</span> <span class="s">^~</span> <span class="s">/avatar/</span> <span class="p">{</span>
    <span class="kn">proxy_pass</span> <span class="s">http://www.avatar.com/</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">www.avatar.com</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>静态文件缓存</h2>
<p>以本战<code>flask</code>程序为例，由于静态文件(比如css/js/图片等)，都是不经常更新的。可以使用<code>nginx</code>的<code>proxy_cache</code>将这些静态文件的响应结果缓存到本地一个目录。这样不仅可以减少服务器处理请求的压力，还有一定程度上提高程序响应速度。</p>
<p>下面是本站缓存配置：</p>
<div class="highlight"><pre><span class="c1"># nginx.conf</span>
<span class="k">http{</span>
    <span class="s">...</span>

    <span class="s">proxy_temp_path</span> <span class="s">/tmp/temp_dir</span><span class="p">;</span>  <span class="c1"># 从后端服务器接收的临时文件的存放路径</span>
    <span class="c1"># 设置缓存的路径和其他参数</span>
    <span class="c1"># levels 设置缓存文件目录层次；levels=1:2 表示两级目录</span>
    <span class="c1"># keys_zone 设置缓存名字和共享内存大小</span>
    <span class="c1"># inactive 在指定时间内没人访问则被删除</span>
    <span class="c1"># max_size 最大缓存空间，如果缓存空间满，默认覆盖掉缓存时间最长的资源。</span>
    <span class="k">proxy_cache_path</span> <span class="s">/tmp/cache</span> <span class="s">levels=1:2</span> <span class="s">keys_zone=tmp_cache:100m</span> <span class="s">inactive=1d</span> <span class="s">max_size=10g</span><span class="p">;</span>

    <span class="k">...</span>

    <span class="s">server</span> <span class="p">{</span>
        <span class="kn">...</span>
    <span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>本站程序的<code>sever</code>块配置在<code>sites-available/default</code>中：</p>
<div class="highlight"><pre><span class="c1"># default</span>
<span class="c1"># 缓存 flask 的static文件夹下所有静态文件</span>
<span class="k">server</span> <span class="s">^~</span> <span class="s">/static/</span> <span class="p">{</span>
    <span class="kn">root</span> <span class="s">/root/project/YuBlog/app/</span><span class="p">;</span> <span class="c1"># 指定文件路径，root不需要在后面加static,alias需要</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
    <span class="kn">proxy_cache</span> <span class="s">tmp_cache</span><span class="p">;</span>  <span class="c1"># 使用名为tmp_cache的对应与http中的缓存配置</span>
    <span class="kn">expires</span> <span class="s">30d</span><span class="p">;</span>  <span class="c1"># 缓存时间</span>
<span class="p">}</span>
</pre></div>


<p>配置完我们需要重启<code>nginx</code>：<code>/usr/local/sbin/nginx -s reload</code></p>
<p>如果没有报错就说明成功了，如果有错误可以使用<code>/usr/local/sbin/nginx -t</code> 查看错误原因。这是打开浏览器可以查看静态文件是否进行缓存了，看响应头中<code>Expires</code>的时间。如果响应头中没有<code>expires</code>信息，而 nginx 也没有出错，那么可能是 nginx 的缓存没有写入权限。这是要在<code>nginx.conf</code>顶部配置有写入权限的用户。</p>
<p><img alt="post36_1" src="https://www.yukunweb.com/qiniu/post36_0.jpg" /></p>
<p>当然，上面反向代理的图片也是可以缓存的，只需要在他们的<code>location</code>配置中加入对应配置就可以了。</p>
<h2>最后</h2>
<p>参考文章：<a href="https://blog.csdn.net/dengjiexian123/article/details/53386586" target="_blank">nginx proxy_cache 缓存配置</a></p>
<p>推荐教程：<a href="http://tengine.taobao.org/book/index.html" target="_blank">从入门到放弃</a></p>]]></content>
  </entry>
  <entry>
    <title>优雅的写判断语句</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/5/write-judgment-sentences-gracefully"/>
    <id>tag:www.yukunweb.com,2018://1.37</id>
    <published>2018-05-20T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>优雅的写判断语句</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="笔记" scheme="http://www.yukunweb.com/category/笔记"/>
    <content type="html"><![CDATA[<p>一个程序之所以能自动做很多任务，是因为我们给他做好了条件判断。项目中，我们难免会使用<code>if/else</code>判断逻辑语句。对简单的情况而言，使用逻辑语句会很清晰简洁，而项目情况一旦复杂，或者判断层次变多，盲目的使用<code>if/else</code>语句就不免会显得难看，而且难以维护和扩展。</p>
<p>比如一个返回今天是什么日子的函数：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_today</span><span class="p">(</span><span class="n">today</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Monday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期一&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Tuesday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期二&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Wednesday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期三&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Thursday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期四&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Friday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期五&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Saturday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期六&#39;</span>
    <span class="k">elif</span> <span class="n">today</span> <span class="o">==</span> <span class="s">&#39;Sunday&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;星期日&#39;</span>
    <span class="k">return</span> <span class="s">&#39;其他&#39;</span>
</pre></div>


<p>这样写虽然没有问题，但是如果现在要多加一个节日，这样我们就又要在现有逻辑中去加一条<code>elif</code>逻辑语句。这样发展下去，代码不仅排版冗长难看，而且增加了修改逻辑语句的风险。</p>
<h2>表驱动法</h2>
<p>表驱动法是一种编写代码的策略，对于复杂的判断逻辑，尽量从表里查找信息而不使用逻辑语句。对于上面的代码，我们可以使用表驱动法，改为：</p>
<div class="highlight"><pre><span class="n">days</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;Monday&#39;</span><span class="p">:</span> <span class="s">&#39;星期一&#39;</span><span class="p">,</span>
    <span class="s">&#39;Tuesday&#39;</span><span class="p">:</span> <span class="s">&#39;星期二&#39;</span><span class="p">,</span>
    <span class="s">&#39;Wednesday&#39;</span><span class="p">:</span> <span class="s">&#39;星期三&#39;</span><span class="p">,</span>
    <span class="s">&#39;Thursday&#39;</span><span class="p">:</span> <span class="s">&#39;星期四&#39;</span><span class="p">,</span>
    <span class="s">&#39;Friday&#39;</span><span class="p">:</span> <span class="s">&#39;星期五&#39;</span><span class="p">,</span>
    <span class="s">&#39;Saturday&#39;</span><span class="p">:</span> <span class="s">&#39;星期六&#39;</span><span class="p">,</span>
    <span class="s">&#39;Sunday&#39;</span><span class="p">:</span> <span class="s">&#39;星期日&#39;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">get_today</span><span class="p">(</span><span class="n">today</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">today</span> <span class="ow">in</span> <span class="n">days</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">days</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">&#39;其他&#39;</span>
</pre></div>


<p>这样我们实际上就将数据和逻辑分离了，好处是数据和逻辑一目了然，维护和扩展更加简单。如果我们需要再加一个节日，只需要在数据中加，不需要去修改逻辑。</p>
<div class="highlight"><pre><span class="n">days</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c"># ...</span>
    <span class="s">&#39;New Year&#39;</span><span class="p">:</span> <span class="s">&#39;春节&#39;</span>
<span class="p">}</span>
</pre></div>


<h2>更复杂的嵌套</h2>
<p>如果我们现在需要把星期和节日区分开，让他们返回不同的信息。</p>
<div class="highlight"><pre><span class="n">days</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;Monday&#39;</span><span class="p">:</span> <span class="s">&#39;星期一&#39;</span><span class="p">,</span>
    <span class="s">&#39;Tuesday&#39;</span><span class="p">:</span> <span class="s">&#39;星期二&#39;</span><span class="p">,</span>
    <span class="s">&#39;Wednesday&#39;</span><span class="p">:</span> <span class="s">&#39;星期三&#39;</span><span class="p">,</span>
    <span class="s">&#39;Thursday&#39;</span><span class="p">:</span> <span class="s">&#39;星期四&#39;</span><span class="p">,</span>
    <span class="s">&#39;Friday&#39;</span><span class="p">:</span> <span class="s">&#39;星期五&#39;</span><span class="p">,</span>
    <span class="s">&#39;Saturday&#39;</span><span class="p">:</span> <span class="s">&#39;星期六&#39;</span><span class="p">,</span>
    <span class="s">&#39;Sunday&#39;</span><span class="p">:</span> <span class="s">&#39;星期日&#39;</span><span class="p">,</span>
    <span class="s">&#39;New Year&#39;</span><span class="p">:</span> <span class="s">&#39;春节&#39;</span><span class="p">,</span>
    <span class="s">&#39;Birthday&#39;</span><span class="p">:</span> <span class="s">&#39;生日&#39;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">get_today</span><span class="p">(</span><span class="n">today</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">today</span> <span class="ow">in</span> <span class="n">days</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">days</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;星期&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&#39;星期几：{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;节&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&#39;节日：{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;今天是：{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;其他&#39;</span>
</pre></div>


<p>这里我们在<code>if/else</code>中又嵌套了一层判断逻辑，当然这只是一层简单的嵌套，这么写没有问题。而随着项目的演进，功能越来越复杂，如果我们需要在嵌套的逻辑中再加一层嵌套，或者更改这层嵌套逻辑。直接在原有的逻辑中改的话，不免要增大修改的代价和风险。更为重要的是，这对以后的维护和扩展增加了难度。</p>
<p>编辑复杂的项目时，为了使代码逻辑更清晰，更易读易于维护，我们需要对原有的<code>if/else</code>中的嵌套做一个类的封装，封装一个判断的方法(<code>judge()</code>)以及一个执行行为方法(<code>action()</code>)，它们分别封装了原代码中的<code>if</code>判断和判断后执行的行为。</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">TodayIsWeek</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;星期&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c"># do something</span>
<span class="k">class</span> <span class="nc">TodayIsFestival</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;节&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c"># do something</span>
<span class="k">class</span> <span class="nc">TodayIsOther</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;星期&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;节&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="c"># do something</span>
</pre></div>


<p>对于上面的程序，这么封装肯定是多余的，而如果程序特别复杂，这样做不仅不会显得过度设计，还能让代码结构逻辑更加清晰。我们只需要将上面的封装放到一个表里，遍历它就可以了：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_today</span><span class="p">(</span><span class="n">today</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">today</span> <span class="ow">in</span> <span class="n">days</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">days</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>
        <span class="c"># 遍历</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TodayIsWeek</span><span class="p">,</span> <span class="n">TodayIsFestival</span><span class="p">,</span> <span class="n">TodayIsOther</span><span class="p">]:</span>
            <span class="n">run</span> <span class="o">=</span> <span class="n">obj</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">run</span><span class="o">.</span><span class="n">judge</span><span class="p">(</span><span class="n">result</span><span class="p">):</span> <span class="k">return</span> <span class="n">run</span><span class="o">.</span><span class="n">action</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;not in days&#39;</span>
</pre></div>


<h2>最后</h2>
<p>在python代码的编写中，我们应该尽量不写过多的逻辑判断嵌套，避免<code>if/else</code>嵌套地狱。对于过于复杂的逻辑判断，尽量对他进行封装，使用表驱动法来分离数据和逻辑，保证可读性同时减少维护代码的成本。</p>]]></content>
  </entry>
  <entry>
    <title>Python爬虫(15):煎蛋网加密处理方式</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/5/jiandan-encryption-processing"/>
    <id>tag:www.yukunweb.com,2018://1.36</id>
    <published>2018-05-08T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>Python爬虫(15):煎蛋网加密处理方式</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="技术" scheme="http://www.yukunweb.com/category/技术"/>
    <content type="html"><![CDATA[<p>最近一直有朋友问我改版的煎蛋网妹子图怎么爬，因为他们花费精力结果抓了一整个文件夹的防盗图。我之前在很久以前的一篇博客说过，对于这种js处理的网页，要想抓取到网页上看到的数据，大致有三种方法：</p>
<ul>
<li>Selenium结合浏览器驱动，直接获取加载js后的页面，解析数据。这种方法最为简单粗暴，不过速度会慢一点，处理煎蛋这样的网页有点大材小用；</li>
<li>直接使用python执行js文件，幸运的是PyV8库很符合要求，不过PyV8似乎不支持python3，python3可以使用PyExecJS库。这种方法也很简单，不过如果执行的js文件依赖pquery库的话，比较麻烦；</li>
<li>用python模拟js加密方式，拿到加密处理后的数据，这种方法就是本篇主要讨论的内容，优点是依赖少速度快，缺点是如果煎蛋加密方式改了，需要跟着改。</li>
</ul>
<h2>分析网页</h2>
<p><img alt="post34_1" src="https://www.yukunweb.com/qiniu/post34_1.png" /></p>
<p>首先打开审查元素看他的实际响应内容，可以看到img标签中实际<code>src</code>属性的值是一个固定的值<code>//img.jandan.net/img/blank.gif</code>。而onload属性指向的是一个js的<code>jandan_load_img()</code>函数，<code>this</code>参数大多数情况是指的当前标签。后面接着span标签包含的一串hash值。</p>
<p>目前我们找到了<code>jandan_load_img()</code>函数，接着就是确定包含这个函数的js文件。方法很简单，在每一个返回的js响应中，去搜索。</p>
<p><img alt="post34_2" src="https://www.yukunweb.com/qiniu/post34_2.png" /></p>
<p>目前的js文件是经过压缩混淆过的，我们可以复制放到线上解压工具里解压。如果用的是Chrome，可以找到source文件，点击如下图标红框的按钮：</p>
<p><img alt="post34_3" src="https://www.yukunweb.com/qiniu/post34_3.png" /></p>
<p><code>jandan_load_img()</code>函数内容为：</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">jandan_load_img</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s2">&quot;span.img-hash&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">jdXFKzuIDxRVqKYQfswJ5elNfow1x0JrJH</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="s2">&quot;zE4N6eHuAQP8vkQPb0wcuEcWnLzHYVhy&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;&#39;</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/(\/\/\w+\.sinaimg\.cn\/)(\w+)(\/.+\.(gif|jpg|jpeg))/</span><span class="p">,</span> <span class="s2">&quot;$1large$3&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot; target=&quot;_blank&quot; class=&quot;view_img_link&quot;&gt;[查看原图]&lt;/a&gt;&#39;</span><span class="p">);</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">);</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">removeAttr</span><span class="p">(</span><span class="s2">&quot;onload&quot;</span><span class="p">);</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="nx">location</span><span class="p">.</span><span class="nx">protocol</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/(\/\/\w+\.sinaimg\.cn\/)(\w+)(\/.+\.gif)/</span><span class="p">,</span> <span class="s2">&quot;$1thumb180$3&quot;</span><span class="p">));</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>


<p>可以看到js文件依赖PQuery库，它拿到img标签，接着拿到后面的span标签内容，然后将它和一个常量传给一串字符的这个函数，拿到这个一串字符的函数返回的内容，放到img和a标签中。</p>
<p>我们在当前js文件搜索是否有这个<code>jdXFKzuIDxRVqKYQfswJ5elNfow1x0JrJH()</code>函数，如果不出意外的话，可以搜索到2个函数。我们选择后面一个，内容如下：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">jdXFKzuIDxRVqKYQfswJ5elNfow1x0JrJH</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="s2">&quot;DECODE&quot;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">r</span> <span class="o">?</span> <span class="nx">r</span> <span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">d</span> <span class="o">?</span> <span class="nx">d</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">));</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="s2">&quot;DECODE&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">o</span> <span class="o">+</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">o</span> <span class="o">+</span> <span class="nx">l</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">k</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="s2">&quot;DECODE&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">m</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">q</span><span class="p">);</span>
        <span class="nx">k</span> <span class="o">=</span> <span class="nx">base64_decode</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">g</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">g</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">[</span><span class="nx">g</span><span class="p">]</span> <span class="o">=</span> <span class="nx">g</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">g</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">g</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">[</span><span class="nx">g</span><span class="p">]</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">g</span> <span class="o">%</span> <span class="nx">c</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">g</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">g</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">+</span> <span class="nx">h</span><span class="p">[</span><span class="nx">g</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="nx">g</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
        <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">h</span><span class="p">[</span><span class="nx">g</span><span class="p">];</span>
        <span class="nx">h</span><span class="p">[</span><span class="nx">g</span><span class="p">]</span> <span class="o">=</span> <span class="nx">h</span><span class="p">[</span><span class="nx">f</span><span class="p">];</span>
        <span class="nx">h</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
    <span class="nx">k</span> <span class="o">=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">g</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">g</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">=</span> <span class="p">(</span><span class="nx">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
        <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">+</span> <span class="nx">h</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
        <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">h</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
        <span class="nx">h</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">h</span><span class="p">[</span><span class="nx">f</span><span class="p">];</span>
        <span class="nx">h</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
        <span class="nx">t</span> <span class="o">+=</span> <span class="nx">chr</span><span class="p">(</span><span class="nx">ord</span><span class="p">(</span><span class="nx">k</span><span class="p">[</span><span class="nx">g</span><span class="p">])</span> <span class="o">^</span> <span class="p">(</span><span class="nx">h</span><span class="p">[(</span><span class="nx">h</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">+</span> <span class="nx">h</span><span class="p">[</span><span class="nx">f</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">]))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="s2">&quot;DECODE&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="nx">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">).</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">t</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">t</span>
<span class="p">};</span>
</pre></div>


<p>拿到这段返回正确url的js代码，我们只要用python语言翻译过来就可以了。</p>
<h2>抓取思路</h2>
<ol>
<li>请求网页拿到html；</li>
<li>从网页中解析出所有img标签后span标签包含的hash值；</li>
<li>正则匹配到html中对应js文件url，请求得到js代码；</li>
<li>正则匹配到js中<code>jandan_load_img()</code>传递给解密函数的常量；</li>
<li>将hash值和常量传递给解密函数，返回对应图片url；</li>
<li>下载图片。</li>
</ol>
<h2>翻译js函数</h2>
<p>对面上面的步骤，我不做多余描述，主要说一下对js代码的翻译，后面会放整理后的代码地址。</p>
<p>如果要翻译上面的js代码，只需要搞清楚代码中调用的函数对应python什么函数就可以了，没有什么难点。</p>
<p><code>md5()</code>是对<code>md5.js</code>的<code>hex_md5()</code>加密方式的封装：</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">md5</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">hex_md5</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>这个方法就相当于python的hashlib库提供的md5摘要加密算法。感兴趣的朋友自行了解，由于后面多次调用此方法，我们对它进行一个封装：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="n">md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
    <span class="n">md5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">md5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
</pre></div>


<p>js中的<code>r.substr(0, 16)</code>调用的是<code>stringObject.substr(start,length)</code>函数。<code>substr()</code>方法可在字符串中抽取从<code>start</code>下标开始的指定<code>length</code>数目的字符。这里注意的是<code>length</code>指的是长度，不是结束的下标，也就是它可以翻译为：</p>
<div class="highlight"><pre><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">16</span><span class="p">]</span>
<span class="n">r</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">32</span><span class="p">]</span> <span class="c"># 注意不是r[16:16]</span>
</pre></div>


<p><code>base64_decode(m)</code>函数是对js的原生Base64编码api的封装：</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">base64_decode</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">window</span><span class="p">.</span><span class="nx">atob</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>大致使用如：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;javascript&#39;</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">btoa</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="c1">//转码结果 &quot;amF2YXNjcmlwdA==&quot;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">atob</span><span class="p">(</span><span class="s2">&quot;amF2YXNjcmlwdA==&quot;</span><span class="p">)</span> <span class="c1">//解码结果 &quot;javascript&quot;</span>
</pre></div>


<p>Base64是一种用64个字符来表示任意二进制数据的方法。幸运的是python内置的有base64库，可以直接进行base64的编解码。我们也对他进行一个封装，方便阅读。这里有一个要注意的是，因为base64是把3个字节变为4个字节，base64编码的长度必须是4的倍数，所以对于不是4的倍数的字符，需要加上=把base64字符串的长度变为4的倍数。</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">decode_base64</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="s">&#39;=&#39;</span><span class="p">)</span>
</pre></div>


<p><code>var h = new Array(256);</code>翻译过来就是<code>h = list(range(256))</code></p>
<p><code>c.charCodeAt(g % c.length)</code>调用的是js的<code>stringObject.charCodeAt(index)</code>函数，返回指定位置的字符的<code>Unicode</code>编码。这个返回值是<code>0 - 65535</code>之间的整数。这个方法相当于python的<code>ord()</code>函数。这行翻译过来就是：</p>
<div class="highlight"><pre><span class="n">b</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">g</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
</pre></div>


<p><code>k = k.split("");</code>是将字符串<code>k</code>分解成单独的字符列表，在python中字符串本身也是一个可迭代对象，忽略就好。</p>
<p><code>chr()</code>和<code>ord()</code>和python内置的<code>chr()</code>、<code>ord()</code>函数类似，我们直接调用对于函数，运行则回报错：<code>ord() expected string of length 1, but int found</code>。因为python中的<code>ord()</code>函数参数是一个<code>str</code>类型的参数，而<code>k[g]</code>实际上是一个字节，我们就不用调用<code>ord()</code>函数就可以了。即：</p>
<div class="highlight"><pre><span class="n">t</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">h</span><span class="p">[(</span><span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">]))</span>
</pre></div>


<h2>最后</h2>
<p>如果进行到这里，基本上对于煎蛋网的抓取已经可以自己实现了。懒得去写的朋友可以直接看我整理好的代码：</p>
<p><a href="https://github.com/Blackyukun/Jiandan">Jiandan</a></p>
<p>拜了个拜。</p>]]></content>
  </entry>
  <entry>
    <title>分裂</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/4/split-life"/>
    <id>tag:www.yukunweb.com,2018://1.35</id>
    <published>2018-04-29T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>分裂</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="生活" scheme="http://www.yukunweb.com/category/生活"/>
    <content type="html"><![CDATA[<p>4月1号那天，网易云下架了周杰伦的音乐，也是那天我在地铁上卸载了这个我使用4年的软件。这个月很多歌火了，前几天室友刷抖音，视频的bgm是一首叫《离人凑》的歌。他觉得好听，就搜出来听。我刚听就觉得熟悉，回味了一会，我靠，这不是 烟花易冷 的旋律吗。我就和室友说他抄袭啊，这歌怎么火的，抄袭杰伦很多年前玩的旋律，还能火起来。他一听到杰伦的名字，脸上就露出不屑之色，我立马打住，默默带上耳机。</p>
<p>我一直觉得自己是一个很有趣的人，比如上次室友说吴京老婆谢楠好漂亮啊，我呵呵一笑，说还不是为了让她老公出演战狼2主角，给导演睡了，然后室友说不信，接着似乎想明白了，便开始给我普及知识。比如我会看到某个很好笑的段子就对他们分享，然后他们总是静静的看我笑的像个傻子。他们一直觉得我很幼稚，我倒是觉得自己很成熟。一起吃饭的时候，他们总是很容易莫名伤感起来，然后就开始喝酒，而有的人明明不能喝，却仍然痛苦的怼着瓶口，很老成的说着莫名其妙的话。当然大多时候我都是意思性的喝饮料，看吧，哪有成熟的人会去为难自己。</p>
<p>实习一个多月了，开始的时候下班回宿舍都会看会书或者写一会代码，最近越来越懒了。再加上总有朋友诱惑我玩游戏，我倒是有些解放天性的感觉，连着玩了几天，后来宿舍的宽带实在是太卡了，坑了好几把。那朋友倒是无所谓，我也不觉得过意不去，只是游戏体验实在太差，就再也不想玩了，还是好好学习吧。说到学习，倒是没学到什么，不过在每天回宿舍的地铁上，为了打发无聊的时间外，除了听音乐，我还爱上了每天写日记。一来记录每天无聊的生活中有趣的事，二来胡乱写些情绪垃圾。</p>
<p><img alt="yw33-1" src="https://www.yukunweb.com/qiniu/post33_1.png" /></p>
<p>记录是生活的缓存，我总是觉得自己无法用文字去表达我的想法。就好比写了这么多，还是不知道自己想说些什么。夏天来了，大街上，地铁上弥漫着情侣们腐朽的恋爱气息。我孑然一身，穿行其间，格外潇洒。只是身后高悬的明月，在冷风的吹拂下显得格外孤独。</p>]]></content>
  </entry>
  <entry>
    <title>Python爬虫(14):搭建免费异步IP代理池</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/4/build-free-asynchronous-proxy-pool"/>
    <id>tag:www.yukunweb.com,2018://1.34</id>
    <published>2018-04-07T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>Python爬虫(14):搭建免费异步IP代理池</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="技术" scheme="http://www.yukunweb.com/category/技术"/>
    <content type="html"><![CDATA[<p>之前写爬虫的时候，经常遇到被封IP的情况。解决办法是控制爬虫请求的时间，这样效率低很多，而且一般网站都会有ip访问阈值监控，超过访问阈值仍然可能会被封。最直接的办法是更换ip，如果可以建议选择付费的代理服务，省事又便捷。当然网上也有很多免费代理，只不过这些代理能不能使用就需要我们自己去检测。</p>
<p>在几个月前，我参考<code>github</code>上的一些项目，搭建过一个代理池。主要作用就是抓取网上的免费代理，经过是否可用的检测，将可以代理放入数据库，并且定时对入库的代理进行检测，保证库中的代理一直是可用的。这样每次爬虫被封ip的时候，便向库中请求一个ip进行更换。最近正好需要使用大量的代理ip，就想起了这个项目，并且做了很大的改进。本篇文章主要写一下代理池的实现。</p>
<h2>代理池设计</h2>
<ul>
<li>
<p>获取器：就是我们的爬虫接口，抓取免费ip，这里我们为了后面的可扩展性，需要支持自由添加爬虫进获取器；</p>
</li>
<li>
<p>数据库：我们选择<code>Mongodb</code>存放有效的代理，上面文章写了关于<code>Mongodb</code>可扩展的封装，我们这里直接搬来使用；</p>
</li>
<li>
<p>调度器：主要是用于检测爬虫是否有效，并添加有效代理入库，定制计划任务检测库中代理，控制爬虫的启动；</p>
</li>
<li>
<p>Api：为了更方便的调用新的代理，我们使用flask做外部接口。</p>
</li>
</ul>
<p>由于免费代理可能在几十分钟后就不能使用，为了每次请求都尽可能从库中拿到可用代理，我们实现一个栈的数据结构，先进后出，后进先出。也就是说每次拿到代理都是从数据库的最右端获取，拿到最新检测过得有效代理。</p>
<p>代理池结构：</p>
<div class="highlight"><pre>ProxyPool \
    Api \
        __init__.py
        api.py
    Spider \
        __init__.py
        get_proxy.py
    Db \
        __init__.py
        db.py
    Schedule \
        __init__.py
        adder.py
        tester.py
        schedule.py
    config.py
    run.py
</pre></div>


<h2>获取器</h2>
<p>我们打开百度输入“免费ip”就可以看到很多提供免费ip的网站，这里我们选择<a href="https://ip.ihuan.me/?page=1&amp;address=5Lit5Zu9">幻代理</a>，<a href="http://www.66ip.cn/areaindex_1/1.html">66代理</a>，<a href="http://www.kuaidaili.com/free/inha/">快代理</a>，<a href="http://www.xicidaili.com/">西刺代理</a>。</p>
<p>主要是有很多代理站点的ip更新时间都很老了，大概率是不能使用的，就不浪费时间了。</p>
<h3>抓取代理</h3>
<p>对代理的抓取，不做多余的叙述，这里以西刺代理为例。对于这些网站的抓取其实很简单，过多的解释是浪费时间。</p>
<p><img alt="xici" src="https://www.yukunweb.com/qiniu/post32_1.png" /></p>
<p>直接上代码：</p>
<div class="highlight"><pre><span class="c"># coding=utf-8</span>
<span class="c"># __author__ = &#39;yk&#39;</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
<span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="kn">import</span> <span class="n">ConnectionError</span>

<span class="k">def</span> <span class="nf">parse_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;User-Agent&#39;</span><span class="p">:</span> <span class="s">&#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&#39;</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">except</span> <span class="n">ConnectionError</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Error.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">proxy_xici</span><span class="p">():</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://www.xicidaili.com/&#39;</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">parse_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">HTML</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="n">ips</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">&#39;//*[@id=&quot;ip_list&quot;]/tr/td[2]/text()&#39;</span><span class="p">)</span>
    <span class="n">ports</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">&#39;//*[@id=&quot;ip_list&quot;]/tr/td[3]/text()&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ips</span><span class="p">,</span> <span class="n">ports</span><span class="p">):</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="n">ip</span> <span class="o">+</span> <span class="s">&#39;:&#39;</span> <span class="o">+</span> <span class="n">port</span>
        <span class="k">yield</span> <span class="n">proxy</span>
</pre></div>


<p>我们使用xpath解析出代理。</p>
<h3>可扩展</h3>
<p>我们需要抓取的网站有四个，未来肯定会更多，为了能够更方便的扩展，我们需要写一个元类。元类主要是控制代理获取类的实现，在获取类中加入两个属性。用于存放类里的每个网站爬虫方法，以及所有爬虫的数量。方便我们在调度器中调用：</p>
<div class="highlight"><pre><span class="c"># Spider/get_proxy.py</span>
<span class="k">class</span> <span class="nc">ProxyMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    元类，在ProxyGetter类中加入</span>
<span class="sd">    __CrawlFunc__和__CrawlFuncCount__两个属性</span>
<span class="sd">    分别表示爬虫函数和爬虫函数的数量</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s">&#39;__CrawlFunc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;proxy_&#39;</span><span class="p">):</span>
                <span class="n">attrs</span><span class="p">[</span><span class="s">&#39;__CrawlFunc__&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s">&#39;__CrawlFuncCount__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ProxyGetter</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ProxyMetaclass</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">proxy_ip66</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">proxy_xici</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">proxy_kuai</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">proxy_ihuan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>


<p><code>__init__</code>方法和<code>__new__</code>方法的区别，我在一次面试中被问到过。这里做一个简单的解释：<code>__new__</code>是一个静态方法，用于控制类的实例创建，也就是在创建实例时调用他。而<code>__init__</code>是一个实例方法，用于初始化一个实例。</p>
<p>这里<code>__new__</code>方法给实例添加两个属性，他的参数分别表示当前类的对象本身(和self类似)，<code>name</code>表示类的名字，<code>bases</code>是一个元组，表示类继承的父类集合，<code>attrs</code>表示类的方法集合，每一个方法是一个键值对。</p>
<p><code>str.startswith('ttt')</code>是判断一个字符串是否以'ttt'开头，相对的有<code>str.endswith('ttt')</code>判断字符串是否以'ttt'结尾。这个方法很方便的将类方法中的爬虫方法过滤出来，将他放入<code>__CrawlFunc__</code>中。</p>
<p>为了方便调用我们还需要一个接口，供以调用爬虫方法：</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">ProxyGetter</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ProxyMetaclass</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_raw_proxies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">proxies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">proxy</span> <span class="ow">in</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;self.{}()&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">callback</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Getting&#39;</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="s">&#39;from&#39;</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="n">proxies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proxies</span>
</pre></div>


<p>python内置的<code>eval</code>函数作用不知道的可以自行查找，这里做一个简单解释：</p>
<div class="highlight"><pre>&gt;&gt;&gt; m = 5
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; eval(&#39;m&#39;) + eval(&#39;n&#39;)
8
</pre></div>


<h2>数据库</h2>
<p>数据库我们直接使用上篇文章封装的类，不过未免存入相同ip，我们需要判断去重。</p>
<div class="highlight"><pre><span class="c"># Db/db.py</span>

<span class="o">...</span>

<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    放置代理到数据库</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxy_num</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;proxy&#39;</span><span class="p">:</span> <span class="n">proxy</span><span class="p">}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#39;proxy&#39;</span><span class="p">:</span> <span class="n">proxy</span><span class="p">,</span> <span class="s">&#39;num&#39;</span><span class="p">:</span> <span class="n">num</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#39;proxy&#39;</span><span class="p">:</span> <span class="n">proxy</span><span class="p">,</span> <span class="s">&#39;num&#39;</span><span class="p">:</span> <span class="n">num</span><span class="p">})</span>
</pre></div>


<p>具体实现可以参考上篇文章。</p>
<h2>调度器</h2>
<p>调度器包含三个部分：</p>
<ul>
<li>
<p>添加类：判断数据库中的代理数量是否达到最大阈值，进行启动爬虫和停止爬虫；</p>
</li>
<li>
<p>测试类：对爬取到的代理进行检测，将有效的代理放入数据库；</p>
</li>
<li>
<p>任务类：定时对数据库中的代理进行检测，用于启动整个调度器。</p>
</li>
</ul>
<p>大致的逻辑就是这样，我们首先来实现一个测试类。</p>
<h3>测试代理</h3>
<p>之前我对代理的检测是直接加上代理，请求百度，如果请求成功返回200响应，就证明代理有效。后来我发现，就算是无效的代理，在请求百度的时候也会出现200响应。所以我选择<code>http://2017.ip138.com/ic.asp</code>这个测试ip的站点作为检测站。大部分人都是在一个服务器上跑代理池和别的爬虫项目，所以代理池应该有很快的速度，这里我们选择在添加代理时异步测试代理是否有效。</p>
<p>我们需要简单的理解python的异步库<code>asyncio</code>和基于<code>asyncio</code>实现的HTTP请求库<code>aiohttp</code>，这里我们使用<code>aiohttp</code>异步请求测试链接，检测代理是否有效，有效就将其放入数据库。</p>
<div class="highlight"><pre><span class="c"># Schedule/tester.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>

<span class="kn">from</span> <span class="nn">Db.db</span> <span class="kn">import</span> <span class="n">MongodbClient</span>
<span class="c"># 将配置信息放入配置文件config.py</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">TEST_URL</span>


<span class="k">class</span> <span class="nc">ProxyTester</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">test_url</span> <span class="o">=</span> <span class="n">TEST_URL</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_proxies</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">set_raw_proxies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxies</span><span class="p">):</span>
        <span class="c"># 供外部添加需要测试的代理</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_proxies</span> <span class="o">=</span> <span class="n">proxies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span> <span class="o">=</span> <span class="n">MongodbClient</span><span class="p">()</span>

    <span class="n">async</span> <span class="k">def</span> <span class="nf">test_single_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        测试一个代理，如果有效，将他放入usable-proxies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                        <span class="n">proxy</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
                    <span class="n">real_proxy</span> <span class="o">=</span> <span class="s">&#39;http://&#39;</span> <span class="o">+</span> <span class="n">proxy</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Testing&#39;</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>
                    <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_url</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="n">real_proxy</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
                            <span class="c"># 请求成功，放入数据库</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
                            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Valid proxy&#39;</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        异步测试所有代理</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Tester is working...&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">test_single_proxy</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span> <span class="k">for</span> <span class="n">proxy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_proxies</span><span class="p">]</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Async Error&#39;</span><span class="p">)</span>
</pre></div>


<p>关于<code>aiohttp</code>的用法，大家可以参考这篇<a href="https://www.jianshu.com/p/0efdc952e8ca">文章</a>。也可以直接参考<a href="https://github.com/HuberTRoy/aiohttp-chinese-documentation">中文文档</a></p>
<p><code>aiohttp</code>大致的get请求方式如：</p>
<div class="highlight"><pre><span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="n">proxy</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">content</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="n">await</span> <span class="n">r</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">await</span> <span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>
</pre></div>


<p><code>test()</code>方法是启动测试的方法，使用<code>asyncio</code>库。<code>asyncio</code>的编程模型就是一个消息循环。最后我们获取一个<code>EventLoop</code>的引用：<code>loop = asyncio.get_event_loop()</code>，然后迭代出所有需要测试的代理，放入测试协程方法，将协程放入<code>EventLoop</code>中去执行。</p>
<p>这样，一个异步测试的类就实现了。</p>
<h3>添加代理</h3>
<p>这个类其实就是一个获取代理的循环，当库中代理数低于最低阈值，就启动爬虫获取代理，然后将这些代理放入测试类中去执行。为了方便添加类的调用，上面的测试类实现了放置需要测试代理的接口<code>set_raw_proxies()</code>方法，爬虫获取类也实现了供外部调用的方法<code>get_raw_proxies()</code>，这样我们只需要调用他们就可以了。</p>
<div class="highlight"><pre><span class="c"># Schedule/adder.py</span>
<span class="kn">from</span> <span class="nn">Db.db</span> <span class="kn">import</span> <span class="n">MongodbClient</span>
<span class="kn">from</span> <span class="nn">Spider.get_proxy</span> <span class="kn">import</span> <span class="n">ProxyGetter</span>
<span class="kn">from</span> <span class="nn">.tester</span> <span class="kn">import</span> <span class="n">ProxyTester</span>


<span class="k">class</span> <span class="nc">PoolAdder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    启动爬虫，添加代理到数据库中</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span> <span class="o">=</span> <span class="n">MongodbClient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span> <span class="o">=</span> <span class="n">ProxyTester</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crawler</span> <span class="o">=</span> <span class="n">ProxyGetter</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_over_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        判断数据库中代理数量是否达到设定阈值</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">get_nums</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span> <span class="k">else</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">add_to_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        补充代理</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;PoolAdder is working...&#39;</span><span class="p">)</span>
        <span class="n">proxy_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_over_threshold</span><span class="p">():</span>
            <span class="c"># 迭代所有的爬虫，元类给ProxyGetter的两个方法</span>
            <span class="c"># __CrawlFuncCount__是爬虫数量，__CrawlFunc__是爬虫方法</span>
            <span class="k">for</span> <span class="n">callback_label</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_crawler</span><span class="o">.</span><span class="n">__CrawlFuncCount__</span><span class="p">):</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crawler</span><span class="o">.</span><span class="n">__CrawlFunc__</span><span class="p">[</span><span class="n">callback_label</span><span class="p">]</span>
                <span class="c"># 调用ProxyGetter()方法进行抓取代理</span>
                <span class="n">raw_proxies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crawler</span><span class="o">.</span><span class="n">get_raw_proxies</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                <span class="c"># 调用方法测试爬取到的代理</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="o">.</span><span class="n">set_raw_proxies</span><span class="p">(</span><span class="n">raw_proxies</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
                <span class="n">proxy_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_proxies</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_over_threshold</span><span class="p">():</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Proxy is enough, waiting to be used...&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">proxy_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;The proxy source is exhausted.&#39;</span><span class="p">)</span>
</pre></div>


<p><code>__CrawlFuncCount__</code>和<code>__CrawlFunc__</code>两个属性这里可以很方便的使我们调用所有爬虫。</p>
<h3>定时启动调度器</h3>
<p>任务类是一个定时执行的程序，他实现一个定时启动调度器，检查数据库代理的方法。这里我们实现两个定时任务，一个是定时取部分代理调用测试类检测，一个是定时检测数据库中的代理是否低于最低阈值，调用添加类添加。所以，我们要实现两个定时任务的循环：</p>
<div class="highlight"><pre><span class="c"># Schedulr/schedule.py</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="kn">from</span> <span class="nn">ProxyPool.db</span> <span class="kn">import</span> <span class="n">MongodbClient</span>
<span class="kn">from</span> <span class="nn">.tester</span> <span class="kn">import</span> <span class="n">ProxyTester</span>
<span class="kn">from</span> <span class="nn">.adder</span> <span class="kn">import</span> <span class="n">PoolAdder</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">VALID_CHECK_CYCLE</span><span class="p">,</span> <span class="n">POOL_LEN_CHECK_CYCLE</span> \
        <span class="n">POOL_LOWER_THRESHOLD</span><span class="p">,</span> <span class="n">POOL_UPPER_THRESHOLD</span>

<span class="k">class</span> <span class="nc">Schedule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">valid_proxy</span><span class="p">(</span><span class="n">cycle</span><span class="o">=</span><span class="n">VALID_CHECK_CYCLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        从数据库中拿到一半代理进行检查</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">MongodbClient</span><span class="p">()</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="n">ProxyTester</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Refreshing ip...&#39;</span><span class="p">)</span>
            <span class="c"># 调用数据库，从左边开始拿到一半代理</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">conn</span><span class="o">.</span><span class="n">get_nums</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Waiting for adding...&#39;</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">raw_proxies</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">set_raw_proxies</span><span class="p">(</span><span class="n">raw_proxies</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_pool</span><span class="p">(</span><span class="n">lower_threshold</span><span class="o">=</span><span class="n">POOL_LOWER_THRESHOLD</span><span class="p">,</span>
                <span class="n">upper_threshold</span><span class="o">=</span><span class="n">POOL_UPPER_THRESHOLD</span><span class="p">,</span>
                <span class="n">cycle</span><span class="o">=</span><span class="n">POOL_LEN_CHECK_CYCLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        如果代理数量少于最低阈值，添加代理</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">MongodbClient</span><span class="p">()</span>
        <span class="n">adder</span> <span class="o">=</span> <span class="n">PoolAdder</span><span class="p">(</span><span class="n">upper_threshold</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">get_nums</span> <span class="o">&lt;</span> <span class="n">lower_threshold</span><span class="p">:</span>
                <span class="n">adder</span><span class="o">.</span><span class="n">add_to_pool</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Ip Processing running...&#39;</span><span class="p">)</span>
        <span class="n">valid_process</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">Schedule</span><span class="o">.</span><span class="n">valid_proxy</span><span class="p">)</span>
        <span class="n">check_process</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">Schedule</span><span class="o">.</span><span class="n">check_pool</span><span class="p">)</span>
        <span class="n">valid_process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">check_process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>


<p>代码中的几个变量需要放置配置文件：</p>
<div class="highlight"><pre><span class="c"># config.py</span>
<span class="c"># Pool 的低阈值和高阈值</span>
<span class="n">POOL_LOWER_THRESHOLD</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">POOL_UPPER_THRESHOLD</span> <span class="o">=</span> <span class="mi">40</span>

<span class="c"># 两个调度进程的周期</span>
<span class="n">VALID_CHECK_CYCLE</span> <span class="o">=</span> <span class="mi">600</span>
<span class="n">POOL_LEN_CHECK_CYCLE</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>


<p><code>valid_proxy</code>方法每次从数据库的左边开始拿到一般代理进行检测，这是因为主要是检测先添加进数据库的代理。然后调用测试类的<code>set_raw_proxies()</code>方法，过滤掉无效代理，将有效代理放于数据库右边。这样可以保证数据库中的代理都可以得到检测。</p>
<p>要拿到数据库的左侧一半代理，我们需要更改数据库<code>get()</code>方法。这一步参考上篇文章不做多余叙述，或者直接参考本项目源码，后面放上。</p>
<p><code>check_pool()</code>方法接收最高和最低阈值和方法周期三个参数。定时判断数据库的代理数量是否低于最低阈值，选择性调用添加类添加代理。</p>
<p>最后开启两个进程，启动两个调度方法。</p>
<h2>API</h2>
<p><code>flask</code>是做<code>api</code>最好的选择，我们只需要提供获取代理以及获取代理总数的接口。这一步主要就是对数据库的链接获取操作，<code>flask</code>路由只需提供<code>/get</code>和<code>/counts</code>路由。这只需要看一下<code>flask</code>文档的第一页就可以了，不做解释。</p>
<h2>启动代理池</h2>
<p>对于启动代理池，我们只需要启动<code>flask</code>的<code>api</code>，和调度器就可以了。</p>
<div class="highlight"><pre><span class="c"># run.py</span>
<span class="kn">from</span> <span class="nn">Api.api</span> <span class="kn">import</span> <span class="n">app</span>
<span class="kn">from</span> <span class="nn">Schedule.schedule</span> <span class="kn">import</span> <span class="n">Schedule</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c"># 任务类的两个周期进程就是整个调度器</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Schedule</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>


<h2>项目地址</h2>
<p><a href="https://github.com/Blackyukun/IPProxyPool">github</a></p>
<p>可以直接<a href="https://github.com/Blackyukun/IPProxyPool/archive/master.zip">下载</a>到本地，切换到项目目录。</p>
<p>安装依赖：<code>pip install -r requirements.txt</code></p>
<p>启动：<code>python run.py</code></p>
<h2>示例</h2>
<p>上面我们已经实现了我们的代理池，下面只是做一个基本的爬虫调用。</p>
<p>首先我们启动代理池：</p>
<div class="highlight"><pre>&gt;&gt;&gt; python run.py
</pre></div>


<p>如果没有报错则，并且显示的信息正常，说明代理池已经启动了。这是打开浏览器访问<code>http://127.0.0.1:5000/get</code>就可以看到一条代理了。</p>
<p><img alt="proxy" src="https://www.yukunweb.com/qiniu/post32_2.png" /></p>
<p>最爬虫中调用：</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>


<span class="k">def</span> <span class="nf">get_proxy</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://127.0.0.1:5000/get&#39;</span><span class="p">)</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">text</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="s">&#39;http://&#39;</span> <span class="o">+</span> <span class="n">proxy</span>
    <span class="k">return</span> <span class="n">ip</span>

<span class="k">def</span> <span class="nf">get_resp</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">get_proxy</span><span class="p">()</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;http&#39;</span><span class="p">:</span> <span class="s">&#39;http://{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)}</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">proxies</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;success&#39;</span><span class="p">)</span>
</pre></div>


<p>周末愉快！</p>]]></content>
  </entry>
  <entry>
    <title>对MongoDB的封装</title>
    <link rel="alternate" type="text/html" href="http://www.yukunweb.com/2018/3/encapsulation-of-mongodb"/>
    <id>tag:www.yukunweb.com,2018://1.33</id>
    <published>2018-03-17T00:00:00Z</published>
    <updated>2018-12-09T00:00:00Z</updated>
    <summary>对MongoDB的封装</summary>
    <author>
    <name>俞坤</name>
    <uri>http://www.yukunweb.com</uri>
    </author>
    <category term="笔记" scheme="http://www.yukunweb.com/category/笔记"/>
    <content type="html"><![CDATA[<p>写爬虫的时候，习惯性会把爬取到的数据存入<code>mongodb</code>。为了方便，也为了每次抓取完数据，不在后面接插入数据的生涩代码。最好的选择是简单的封装<code>mongodb</code>的增删改查功能，如果后面使用<code>mongodb</code>的时候可以直接调用它，一劳永逸。</p>
<h2>pymongo</h2>
<p>其实<code>pymongo</code>这个库已经为我们很好的封装了对数据库的操作，但是我总是很容易忘记或者搞混他的 api。我想实现如果创建数据库，只需要配置好数据库的<code>name</code>，<code>host</code>，<code>port</code>，增加数据：<code>put(data)</code>，删除数据：<code>delete(data)</code>。</p>
<p>这样的话，每次需要使用<code>mongodb</code>的时候，只需要简单配置，不再需要谷歌他的文档 api，上手即用。</p>
<h2>封装</h2>
<p>首先我们创建一个<code>MongodbClient</code>类，在向类里面增加对应的功能。</p>
<div class="highlight"><pre><span class="c"># db.py</span>
<span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span><span class="p">,</span> <span class="n">ASCENDING</span>
<span class="c"># 我们把配置文件放入 config.py 文件内</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span>


<span class="k">class</span> <span class="nc">MongodbClient</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">TABLE</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">HOST</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">PORT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">MongoClient</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">NAME</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取表里的数据总数&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">change_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;切换数据库表&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span>

    <span class="k">def</span> <span class="nf">set_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;给每条数据设置唯一自增num&quot;&quot;&quot;</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">datas</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datas</span><span class="p">:</span>
                <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;num&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取最新一条数据&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">()</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取指定num的数据&quot;&quot;&quot;</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">datas</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">datas</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s">&#39;num&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">num</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;获取全部数据&quot;&quot;&quot;</span>
        <span class="c"># 判断表里是否有数据</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_counts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># 先排序</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">()]</span>
            <span class="k">return</span> <span class="n">datas</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;添加数据&quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_num</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c"># 判断是否重复</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c"># 重复则删除，重新插入</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s">&#39;num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s">&#39;num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;删除数据&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;清空表&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">drop_database</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;按num键排序&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">,</span> <span class="n">ASCENDING</span><span class="p">)</span>
</pre></div>


<p>常用的功能大致就这么多，如果不够用可以自由扩展。</p>
<h2>简述</h2>
<p>上面的封装其实主要是对<code>pymongo</code>库的封装，给每个数据插入自增的<code>num</code>键是我在抓取IP代理的时候加的，这样做并且基于<code>num</code>键排序。在IP代理池的爬虫项目中，实际上就是实现了一个栈的数据结构。添加代理进数据库，每次获取取最新添加的代理(get_new())，后进先出。当然我写的很多爬虫都是用的这个封装，方便就好。</p>
<p>在插入数据库的方法上，我选择先对它进行去重操作，其实如果重复可以直接选择不插入，而我是选择删除旧的插入新的。其实这里可以不用去判断整个数据是否重复，如果是某一类数据，比如所有数据不可以出现重复的名字，我们就需要判断名字是否和库中的某条数据重复。这样我们可以这么改：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;添加数据&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]}):</span>

        <span class="o">...</span>
</pre></div>


<p>是不是很方便。</p>
<h2>翻页数据</h2>
<p>如果使用<code>flask</code>结合<code>mongodb</code>数据库使用，如果数据库中有50条数据，而我们只需要每页显示10条。这样我们可以对封装添加分页显示数据的操作：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_page</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    分页数据</span>
<span class="sd">    :param page: 页数</span>
<span class="sd">    :param count: 每页条数</span>
<span class="sd">    :return: 每页数据</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># 判断是否有数据</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nums</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># 排序</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c"># 如果整除count为0，就直接返回为第一页</span>
        <span class="n">pages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nums</span> <span class="o">//</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nums</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">paginate</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pages</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">skip</span><span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="n">paginate</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">:</span> <span class="n">datas</span><span class="p">})</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">paginate</span> <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="s">&#39;page&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">page</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>我们使用<code>self.db[self.table].find().limit(10)</code>来保证只显示10条数据，<code>.skip(10)</code>可以帮我们过滤掉前面的10条数据。这样是不是相当于显示第二页的数据了。</p>
<p>这是我写爬虫时对数据库操作进行的简单的封装，显然对于很多简单的项目已经很满足使用了，如果需要更多功能，添加起来也是很简单的。当然有很多可以改进的地方，比如列表生成式可以改用生成器，这样实现更好些。</p>]]></content>
  </entry>
</feed>